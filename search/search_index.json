{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"p3-db P3\\Db is a small database abstraction layer on top of the \\PDO library. It provides a simple sql builder and convenience methods for common CRUD opeations. The DBAL instance consists of a simple PDO connection wrapper that can either use an existing connection or instantiate a new lazy pdo connection on demand. Basic database operations for retrieving, inserting, updating and deleting rows from/into a given database table leverage a set of database Command classes, which in turn compose the database connection itself and a corresponding sql abstraction statement object. The sql-command building operations are forwarded to the composed sql abstraction layer object, while the sql statement preparation, parameter binding and command execution are performed by the composed DBAL instance. Installation p3-db DBAL requires php >= 7.1 and can be installed via composer $ composer require pine3ree/p3-db The package does not provide any stable version yet, so \"minimum-stability\": \"dev\" setting is required in your composer.json file. Features The library's code is splitted into two main sections/namespaces: a Sql section in which sql generation of full statements or smaller sfragments is abstracted a Command section which offers objects that actually send the sql statements to the database server by means ot the composed connection and retrieve the results of such operations such as row/record set for DQL statements and of number of affected rows for DML statements.","title":"Home"},{"location":"#p3-db","text":"P3\\Db is a small database abstraction layer on top of the \\PDO library. It provides a simple sql builder and convenience methods for common CRUD opeations. The DBAL instance consists of a simple PDO connection wrapper that can either use an existing connection or instantiate a new lazy pdo connection on demand. Basic database operations for retrieving, inserting, updating and deleting rows from/into a given database table leverage a set of database Command classes, which in turn compose the database connection itself and a corresponding sql abstraction statement object. The sql-command building operations are forwarded to the composed sql abstraction layer object, while the sql statement preparation, parameter binding and command execution are performed by the composed DBAL instance.","title":"p3-db"},{"location":"#installation","text":"p3-db DBAL requires php >= 7.1 and can be installed via composer $ composer require pine3ree/p3-db The package does not provide any stable version yet, so \"minimum-stability\": \"dev\" setting is required in your composer.json file.","title":"Installation"},{"location":"#features","text":"The library's code is splitted into two main sections/namespaces: a Sql section in which sql generation of full statements or smaller sfragments is abstracted a Command section which offers objects that actually send the sql statements to the database server by means ot the composed connection and retrieve the results of such operations such as row/record set for DQL statements and of number of affected rows for DML statements.","title":"Features"},{"location":"db/","text":"P3\\Db Quick start use P3\\Db; use P3\\Db\\Factory\\DbFactory; use PDO; // 1. Create a dbal instance using an existing PDO connection $pdo = new PDO('my-db-dsn', 'my-db-username', 'my-db-password'); $db = new Db($pdo); // 2. Create a dbal instance using pdo configuration: the PDO connection is created on demand $db = new Db('my-db-dsn', 'my-db-username', 'my-db-password'); // 3. Create a dbal instance using a factory: the provided factory fetch a configuration // array from a psr-container under the `config` id/alias with specific database // configuration subarray under either a `db` or `pdo` key. $factory = new DbFactory(); $db = $factory($container); // Simple proxy method to \\PDO::query() returning a traversable PDOStatement or // false if query execution fails $stmt = $db->query('SELECT * FROM product WHERE price < 100.0 AND id < 100'); // Simple proxy method to \\PDO::exec(), returns the number of affected rows, or // false if execution fails $affected = $db->exec('UPDATE product SET published = FALSE WHERE stock <= 0'); Other examples: // fetch all rows from the \"product\" table // fetchAll(string $table, $where = null, $order = null, int $limit = null, int $offset = null): array $products = $db->fetchAll('product'); // fetch the product row with column id = 42 // fetchOneBy(string $table, string $column, $value, $order = null): ?array $product = $db->fetchOneBy('product', 'id', 42); // same row using `fetchOne()` with condition // fetchOne(string $table, $where = null, $order = null): ?array $product = $db->fetchOne('product', ['id' => 42]); $fiftyExpensiveProducts = $db->fetchAll('product', [ ['price', '>', 1000.00], ], ['price' => 'ASC'], 50); $tenMostExpensiveProducts = $db->fetchAll('product', null, ['price' => 'DESC'], 10); $mostExpensiveProduct = $db->fetchOne('product', null, ['price' => 'DESC']); Constructor arguments P3\\Db supports the same constructor arguments as the \\PDO class. It also supports an extra argument, an optional custom PDO subclass to use in lazy connection instances. class Db { /** * @param string|PDO $dsn_or_pdo A valid pdo dsn string or an existing pdo connection instance * @param string|null $username PDO connection username * @param string|null $password PDO connection password * @param array|null $options PDO connection options * @param string|null $pdoClass An optional PDO subclass to use when creating a new connection */ public function __construct( $dsn_or_pdo, string $username = null, string $password = null, array $options = null, string $pdoClass = null ) { } //... The first argument can also be an existing PDO instance itself, that will be used as the composed pdo connection. Factory configuration parameters Factory configuration retrieved from the container should return an array like the one below: // file config.php return [ // full dsn specification 'db' => [ // alt key: 'pdo' => [...] 'dns' => 'mysql:dbname=testdb;host=localhost;port=3306;charset=utf8', 'username' => 'testuser', // alt key: 'user' 'password' => 'secret', // alt key: 'passwd' or 'pass' ], // ...or single parameters specs 'db' => [ 'driver' => 'mysql', 'dbname' => 'testdb', // alt key: 'database' 'host' => 'localhost', // alt key: 'hostname' 'port' => 3306, 'charset' => 'utf8', 'username' => 'testuser', // alt key: 'user' 'password' => 'secret', // alt key: 'passwd' or 'pass' 'options' => [ // pdo-options array ] ], ]; The database configuration subkeys depend on the db driver used and must be all in snake_case format. Please check the pdo driver page https://www.php.net/manual/en/pdo.drivers.php for more information. The factory will attempt to build a valid pdo DSN with the provided configuration parameters. Supported drivers are mysql , pgsql , sqlite , sqlsrv and oci . CRUD commands To start building a crud databse command you can use the following methods: $select = $db->select(); // returns a P3\\Db\\Command\\Select instance $insert = $db->insert(); // returns a P3\\Db\\Command\\Insert instance $update = $db->update(); // returns a P3\\Db\\Command\\Update instance $delete = $db->delete(); // returns a P3\\Db\\Command\\Delete instance Database command instances provide a fluent interface for building sql statement. The sql build is actually perfomed by the composed sql-statement ( P3\\Db\\Sql\\Statement ) instance with the help of the sql-driver ( P3\\Sql\\DriverInterface ) created for the current connection. The corresponding sql-statement objects ca be created with the following P3\\Db\\Sql helper class static methods: $select = Sql::select(); // returns a P3\\Db\\Sql\\Statement\\Select instance $insert = Sql::insert(); // returns a P3\\Db\\Sql\\Statement\\Insert instance $update = Sql::update(); // returns a P3\\Db\\Sql\\Statement\\Update instance $delete = Sql::delete(); // returns a P3\\Db\\Sql\\Statement\\Delete instance The Sql\\Statement classes, as any other Sql\\Element class, provide a getSQL() method which compiles the sql string for the given sql-driver argument or the default Ansi driver. The sql-drivers provide identifier quoting and other sql transformations according to the underlying platform. The getSQL() method also collects user-provided parameter values along with their pdo-param types and sets named markers in their place into the sql string. The paramater collector can be retrieved by getParams() either from the sql-statement object or the wrapping command. A internal collector will be created only if not passed-in as the 2nd argument of the getSQL() call. All database command classes implement the execute() method. For writer-DML-commands (Insert|Update|Delete) execute() will call the writer method Writer::exec() and will return either the number of rows affected or false on failure. For reader-DQL-commands (Select) execute() will call the reader method Reader::query() and will return either a traversable \\PDOStatement result-set object or false on failure. Unless otherwise stated in all the examples' compiled sql-strings identifiers and aliases will be quoted according to an implied Ansi driver, i.e. using double quotes \" . Db::select() Create a P3\\Db\\Command\\Select reader command instance use P3\\Db; use P3\\Db\\Sql; /** @var Db $db */ $select = $db->select(); // create a generic empty Select command instance // SELECT * FROM \"product\" $select = $db->select('*', 'product'); $select = $db->select('*')->from('product'); $select = $db->select(null, 'product'); $select = $db->select()->from('product'); // use table alias: SELECT * FROM \"product\" \"p\" $select = $db->select('*', 'product', 'p'); $select = $db->select('*')->from('product', 'p'); $select = $db->select()->from('product', 'p'); // SELECT \"p\".\"price\", \"p\".\"vat_rate\" AS \"vatRate\" FROM \"product\" \"p\" $select = $db->select(['price', 'vat_rate' => 'vatRate'])->from('product', 'p'); // add where condition LessThanEqual and order-by clause $select->where->lte('price', 1000.0); // WHERE \"price\" <= :lte1 (named parameter marker) // ORDER BY \"p\".\"price\" ASC $select->orderBy('p.price', 'ASC'); $select->orderBy('p.price', Sql::ASC); // ORDER BY \"price\" ASC, \"vat_rate\" DESC $select->orderBy([ 'price' => Sql::ASC, // or just 'price' => 'ASC' 'vat_rate' => Sql::DESC, // or just 'vat_rate' => 'DESC' ]); $stmt = $select->execute(); // or $select->query(), returns a \\PDOStatement instance or FALSE // SELECT // \"category_id\" AS \"catId\", // COUNT(*) AS \"numProducts\" // FROM \"product\" WHERE \"price\" > :gt1 // GROUP BY \"category_id\" // HAVING \"numProducts\" >= :gte1 $select = $db->select() ->column('category_id', 'catId') ->count('*', 'numProducts') ->from('product'); ->where->gte('price', 10.0); // using $select->where or $select->having changes the scope and the fluent interface // method chain is broken // add a GROUP BY // GROUP BY \"category_id\" HAVING \"numProducts\" < :lte1 $select->groupBy('category_id') ->having->lte('numProducts', 5); // SELECT MIN(\"price\") FROM \"product\" GROUP BY \"category_id\" $select = $db->select()->min('price')->from('product')->groupBy('category_id'); Db::insert() Create and optionally execute an P3\\Db\\Command\\Insert writer command instance. // INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2) $insert = $db->insert() ->into('product') ->row([ 'name' => 'product-1', 'price' => 100.00, ]); // equivalent to $insert = $db->insert() ->into('product') ->columns(['name', 'price']) ->values(['product-1', 100.00]); $result = $insert->execute() // or $insert->exec(), returns TRUE or FALSE for single row insert Insert and execute shortcut call, when both arguments ( $table and $row / $rows ) are provided: $result = $db->insert('product', [ 'name' => 'product-111', 'price' => 111.11, ]); // returns TRUE or FALSE for single insert // get the last generated value if the insert is successful $id = $result ? $db->lastInsertId() : null; Insert many rows: // INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2), (:val3, :val4) $num_inserted = $db->insert('product', [ [ 'name' => 'product-111', 'price' => 111.11, ], [ 'name' => 'product-222', 'price' => 222.22, ], ]); // returns integer or FALSE for multi-rows inserts // equivalent to $num_inserted = $db->insert() ->into('product') ->rows([ [ 'name' => 'product-111', 'price' => 111.11, ], [ 'name' => 'product-222', 'price' => 222.22, ], ])->execute(); // or exec() // and to $num_inserted = $db->insert() ->into('product') ->columns(['name', 'price']) ->values([ 'product-111', 111.11, ]) ->values([ 'product-222', 222.22, ])->execute(); // or exec() // and to $num_inserted = $db->insert() ->into('product') ->columns(['name', 'price']) ->multipleValues([ [ 'product-111', 111.11, ], [ 'product-222', 222.22, ], ])->execute(); By default Insert::values(array $values, bool $reset = false) and Insert::row(array $row, bool $reset = false) will add new inset values to existing ones. This can be changed by setting the 2nd argument to true : $insert = $db->insert('product'); $insert->row(['price' => 111.11, 'stock' => 111]); // adds 1 set of values $insert->row(['price' => 222.22, 'stock' => 222]); // adds 1 set of values // columns \"price\" and \"stock\" are alredy specified by previuous row() calls $insert->values([333.33, 333]); // adds 1 set of values $insert->execute(); // this will try to insert 3 rows $insert->values([444.44, 444]); // adds another set of values $insert->execute(); // this will try to insert 4 rows // adds 1 set of values after removing the old ones $insert->row(['price' => 555.55, 'stock' => 555], true); $insert->execute(); // this will try to insert 1 row The opposite happens for Insert::rows(array $rows, bool $reset = true) and Insert::multipleValues(array $values, bool $reset = true) . These methods calls will insert the exact rows/values provided unless the 2nd argument is set to false . Db::update() The P3\\Db\\Command\\Update command abstracts an INSERT operation A non empty condition/predicate is required, otherwise an exception is thrown. Examples: // UPDATE \"product\" SET \"published\" = :set1 WHERE stock > 0 $update = $db->update()->table('product')->set('published', true)->where('stock > 0'); $update = $db->update('product')->set('published', true)->where('stock > 0'); $affected = $update->execute(); // or exec() // immediate command execution // UPDATE \"product\" SET \"published\" = :set1 WHERE TRUE, we use the condition \"TRUE\" to update all records $affected = $db->update('product', ['published' => true], 'TRUE'); Db::delete() The P3\\Db\\Command\\Delete command abstracts a SQL DELETE operation A non empty condition/predicate is required, otherwise an exception is thrown. Examples: // DELETE FROM \"product\" WHERE stock <= 0 $delete = $db->delete()->from('product')->where('stock <= 0'); $delete = $db->delete('product')->where('stock <= 0'); $num_deleted = $delete->execute(); // or exec() // immediate command execution // DELETE FROM \"product\" WHERE stock <= 0 $num_deleted = $db->delete('product', 'stock <= 0'); Sql driver proxy helper methods The following methods are simple proxies to methods implemented in the P3\\Db\\Sql\\DriverInterface class of the current dbal's sql-driver instance. Db::quoteIdentifier(string $identifier) quotes given column/table SQL identifier Db::quoteAlias(string $alias) quotes given SQL aliase Db::quoteValue(null|scalar $value) perform type-casting and quotes - when required - the given value","title":"Db"},{"location":"db/#p3db","text":"","title":"P3\\Db"},{"location":"db/#quick-start","text":"use P3\\Db; use P3\\Db\\Factory\\DbFactory; use PDO; // 1. Create a dbal instance using an existing PDO connection $pdo = new PDO('my-db-dsn', 'my-db-username', 'my-db-password'); $db = new Db($pdo); // 2. Create a dbal instance using pdo configuration: the PDO connection is created on demand $db = new Db('my-db-dsn', 'my-db-username', 'my-db-password'); // 3. Create a dbal instance using a factory: the provided factory fetch a configuration // array from a psr-container under the `config` id/alias with specific database // configuration subarray under either a `db` or `pdo` key. $factory = new DbFactory(); $db = $factory($container); // Simple proxy method to \\PDO::query() returning a traversable PDOStatement or // false if query execution fails $stmt = $db->query('SELECT * FROM product WHERE price < 100.0 AND id < 100'); // Simple proxy method to \\PDO::exec(), returns the number of affected rows, or // false if execution fails $affected = $db->exec('UPDATE product SET published = FALSE WHERE stock <= 0'); Other examples: // fetch all rows from the \"product\" table // fetchAll(string $table, $where = null, $order = null, int $limit = null, int $offset = null): array $products = $db->fetchAll('product'); // fetch the product row with column id = 42 // fetchOneBy(string $table, string $column, $value, $order = null): ?array $product = $db->fetchOneBy('product', 'id', 42); // same row using `fetchOne()` with condition // fetchOne(string $table, $where = null, $order = null): ?array $product = $db->fetchOne('product', ['id' => 42]); $fiftyExpensiveProducts = $db->fetchAll('product', [ ['price', '>', 1000.00], ], ['price' => 'ASC'], 50); $tenMostExpensiveProducts = $db->fetchAll('product', null, ['price' => 'DESC'], 10); $mostExpensiveProduct = $db->fetchOne('product', null, ['price' => 'DESC']);","title":"Quick start"},{"location":"db/#constructor-arguments","text":"P3\\Db supports the same constructor arguments as the \\PDO class. It also supports an extra argument, an optional custom PDO subclass to use in lazy connection instances. class Db { /** * @param string|PDO $dsn_or_pdo A valid pdo dsn string or an existing pdo connection instance * @param string|null $username PDO connection username * @param string|null $password PDO connection password * @param array|null $options PDO connection options * @param string|null $pdoClass An optional PDO subclass to use when creating a new connection */ public function __construct( $dsn_or_pdo, string $username = null, string $password = null, array $options = null, string $pdoClass = null ) { } //... The first argument can also be an existing PDO instance itself, that will be used as the composed pdo connection.","title":"Constructor arguments"},{"location":"db/#factory-configuration-parameters","text":"Factory configuration retrieved from the container should return an array like the one below: // file config.php return [ // full dsn specification 'db' => [ // alt key: 'pdo' => [...] 'dns' => 'mysql:dbname=testdb;host=localhost;port=3306;charset=utf8', 'username' => 'testuser', // alt key: 'user' 'password' => 'secret', // alt key: 'passwd' or 'pass' ], // ...or single parameters specs 'db' => [ 'driver' => 'mysql', 'dbname' => 'testdb', // alt key: 'database' 'host' => 'localhost', // alt key: 'hostname' 'port' => 3306, 'charset' => 'utf8', 'username' => 'testuser', // alt key: 'user' 'password' => 'secret', // alt key: 'passwd' or 'pass' 'options' => [ // pdo-options array ] ], ]; The database configuration subkeys depend on the db driver used and must be all in snake_case format. Please check the pdo driver page https://www.php.net/manual/en/pdo.drivers.php for more information. The factory will attempt to build a valid pdo DSN with the provided configuration parameters. Supported drivers are mysql , pgsql , sqlite , sqlsrv and oci .","title":"Factory configuration parameters"},{"location":"db/#crud-commands","text":"To start building a crud databse command you can use the following methods: $select = $db->select(); // returns a P3\\Db\\Command\\Select instance $insert = $db->insert(); // returns a P3\\Db\\Command\\Insert instance $update = $db->update(); // returns a P3\\Db\\Command\\Update instance $delete = $db->delete(); // returns a P3\\Db\\Command\\Delete instance Database command instances provide a fluent interface for building sql statement. The sql build is actually perfomed by the composed sql-statement ( P3\\Db\\Sql\\Statement ) instance with the help of the sql-driver ( P3\\Sql\\DriverInterface ) created for the current connection. The corresponding sql-statement objects ca be created with the following P3\\Db\\Sql helper class static methods: $select = Sql::select(); // returns a P3\\Db\\Sql\\Statement\\Select instance $insert = Sql::insert(); // returns a P3\\Db\\Sql\\Statement\\Insert instance $update = Sql::update(); // returns a P3\\Db\\Sql\\Statement\\Update instance $delete = Sql::delete(); // returns a P3\\Db\\Sql\\Statement\\Delete instance The Sql\\Statement classes, as any other Sql\\Element class, provide a getSQL() method which compiles the sql string for the given sql-driver argument or the default Ansi driver. The sql-drivers provide identifier quoting and other sql transformations according to the underlying platform. The getSQL() method also collects user-provided parameter values along with their pdo-param types and sets named markers in their place into the sql string. The paramater collector can be retrieved by getParams() either from the sql-statement object or the wrapping command. A internal collector will be created only if not passed-in as the 2nd argument of the getSQL() call. All database command classes implement the execute() method. For writer-DML-commands (Insert|Update|Delete) execute() will call the writer method Writer::exec() and will return either the number of rows affected or false on failure. For reader-DQL-commands (Select) execute() will call the reader method Reader::query() and will return either a traversable \\PDOStatement result-set object or false on failure. Unless otherwise stated in all the examples' compiled sql-strings identifiers and aliases will be quoted according to an implied Ansi driver, i.e. using double quotes \" .","title":"CRUD commands"},{"location":"db/#dbselect","text":"Create a P3\\Db\\Command\\Select reader command instance use P3\\Db; use P3\\Db\\Sql; /** @var Db $db */ $select = $db->select(); // create a generic empty Select command instance // SELECT * FROM \"product\" $select = $db->select('*', 'product'); $select = $db->select('*')->from('product'); $select = $db->select(null, 'product'); $select = $db->select()->from('product'); // use table alias: SELECT * FROM \"product\" \"p\" $select = $db->select('*', 'product', 'p'); $select = $db->select('*')->from('product', 'p'); $select = $db->select()->from('product', 'p'); // SELECT \"p\".\"price\", \"p\".\"vat_rate\" AS \"vatRate\" FROM \"product\" \"p\" $select = $db->select(['price', 'vat_rate' => 'vatRate'])->from('product', 'p'); // add where condition LessThanEqual and order-by clause $select->where->lte('price', 1000.0); // WHERE \"price\" <= :lte1 (named parameter marker) // ORDER BY \"p\".\"price\" ASC $select->orderBy('p.price', 'ASC'); $select->orderBy('p.price', Sql::ASC); // ORDER BY \"price\" ASC, \"vat_rate\" DESC $select->orderBy([ 'price' => Sql::ASC, // or just 'price' => 'ASC' 'vat_rate' => Sql::DESC, // or just 'vat_rate' => 'DESC' ]); $stmt = $select->execute(); // or $select->query(), returns a \\PDOStatement instance or FALSE // SELECT // \"category_id\" AS \"catId\", // COUNT(*) AS \"numProducts\" // FROM \"product\" WHERE \"price\" > :gt1 // GROUP BY \"category_id\" // HAVING \"numProducts\" >= :gte1 $select = $db->select() ->column('category_id', 'catId') ->count('*', 'numProducts') ->from('product'); ->where->gte('price', 10.0); // using $select->where or $select->having changes the scope and the fluent interface // method chain is broken // add a GROUP BY // GROUP BY \"category_id\" HAVING \"numProducts\" < :lte1 $select->groupBy('category_id') ->having->lte('numProducts', 5); // SELECT MIN(\"price\") FROM \"product\" GROUP BY \"category_id\" $select = $db->select()->min('price')->from('product')->groupBy('category_id');","title":"Db::select()"},{"location":"db/#dbinsert","text":"Create and optionally execute an P3\\Db\\Command\\Insert writer command instance. // INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2) $insert = $db->insert() ->into('product') ->row([ 'name' => 'product-1', 'price' => 100.00, ]); // equivalent to $insert = $db->insert() ->into('product') ->columns(['name', 'price']) ->values(['product-1', 100.00]); $result = $insert->execute() // or $insert->exec(), returns TRUE or FALSE for single row insert Insert and execute shortcut call, when both arguments ( $table and $row / $rows ) are provided: $result = $db->insert('product', [ 'name' => 'product-111', 'price' => 111.11, ]); // returns TRUE or FALSE for single insert // get the last generated value if the insert is successful $id = $result ? $db->lastInsertId() : null; Insert many rows: // INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2), (:val3, :val4) $num_inserted = $db->insert('product', [ [ 'name' => 'product-111', 'price' => 111.11, ], [ 'name' => 'product-222', 'price' => 222.22, ], ]); // returns integer or FALSE for multi-rows inserts // equivalent to $num_inserted = $db->insert() ->into('product') ->rows([ [ 'name' => 'product-111', 'price' => 111.11, ], [ 'name' => 'product-222', 'price' => 222.22, ], ])->execute(); // or exec() // and to $num_inserted = $db->insert() ->into('product') ->columns(['name', 'price']) ->values([ 'product-111', 111.11, ]) ->values([ 'product-222', 222.22, ])->execute(); // or exec() // and to $num_inserted = $db->insert() ->into('product') ->columns(['name', 'price']) ->multipleValues([ [ 'product-111', 111.11, ], [ 'product-222', 222.22, ], ])->execute(); By default Insert::values(array $values, bool $reset = false) and Insert::row(array $row, bool $reset = false) will add new inset values to existing ones. This can be changed by setting the 2nd argument to true : $insert = $db->insert('product'); $insert->row(['price' => 111.11, 'stock' => 111]); // adds 1 set of values $insert->row(['price' => 222.22, 'stock' => 222]); // adds 1 set of values // columns \"price\" and \"stock\" are alredy specified by previuous row() calls $insert->values([333.33, 333]); // adds 1 set of values $insert->execute(); // this will try to insert 3 rows $insert->values([444.44, 444]); // adds another set of values $insert->execute(); // this will try to insert 4 rows // adds 1 set of values after removing the old ones $insert->row(['price' => 555.55, 'stock' => 555], true); $insert->execute(); // this will try to insert 1 row The opposite happens for Insert::rows(array $rows, bool $reset = true) and Insert::multipleValues(array $values, bool $reset = true) . These methods calls will insert the exact rows/values provided unless the 2nd argument is set to false .","title":"Db::insert()"},{"location":"db/#dbupdate","text":"The P3\\Db\\Command\\Update command abstracts an INSERT operation A non empty condition/predicate is required, otherwise an exception is thrown. Examples: // UPDATE \"product\" SET \"published\" = :set1 WHERE stock > 0 $update = $db->update()->table('product')->set('published', true)->where('stock > 0'); $update = $db->update('product')->set('published', true)->where('stock > 0'); $affected = $update->execute(); // or exec() // immediate command execution // UPDATE \"product\" SET \"published\" = :set1 WHERE TRUE, we use the condition \"TRUE\" to update all records $affected = $db->update('product', ['published' => true], 'TRUE');","title":"Db::update()"},{"location":"db/#dbdelete","text":"The P3\\Db\\Command\\Delete command abstracts a SQL DELETE operation A non empty condition/predicate is required, otherwise an exception is thrown. Examples: // DELETE FROM \"product\" WHERE stock <= 0 $delete = $db->delete()->from('product')->where('stock <= 0'); $delete = $db->delete('product')->where('stock <= 0'); $num_deleted = $delete->execute(); // or exec() // immediate command execution // DELETE FROM \"product\" WHERE stock <= 0 $num_deleted = $db->delete('product', 'stock <= 0');","title":"Db::delete()"},{"location":"db/#sql-driver-proxy-helper-methods","text":"The following methods are simple proxies to methods implemented in the P3\\Db\\Sql\\DriverInterface class of the current dbal's sql-driver instance. Db::quoteIdentifier(string $identifier) quotes given column/table SQL identifier Db::quoteAlias(string $alias) quotes given SQL aliase Db::quoteValue(null|scalar $value) perform type-casting and quotes - when required - the given value","title":"Sql driver proxy helper methods"},{"location":"sql/drivers/","text":"p3\\Db\\Sql\\DriverInterface","title":"Drivers"},{"location":"sql/drivers/#p3dbsqldriverinterface","text":"","title":"p3\\Db\\Sql\\DriverInterface"},{"location":"sql/elements/","text":"P3\\Db\\Sql\\ElementInterface A sql element represents full sql statements or just part of it such as identifiers, aliases, predicate, clauses, etc... It provides a getSQL(DriverInterface $driver = null, Params $params = null) method that returns the compiled SQL-string for the elements itself with the help of the given driver and collects parameter values and types to be used when the sql-statements are being prepared to be sent to the database server. Sql elements can also be organized in hierarchies ( ElementInterface::setParent() ), but an element can have only one parent. Changes to an inner element must invalidate any compiled sql-string that has been cached. P3\\Db\\Sql The Db\\Sql class offers constants for common SQL keywords and static factory methods for creating complex or simple sql elements: use P3\\Db\\Sql; use P3\\Db\\Sql\\Alias; use P3\\Db\\Sql\\Expression; use P3\\Db\\Sql\\Literal; use P3\\Db\\Sql\\Identifier; use P3\\Db\\Sql\\Statement; // Create Identifier elements: dots are considered identifier separators $column = Sql::identifier('category_id'); // sql-string: \"category_id\" $column = Sql::identifier('p.category_id'); // sql-string: \"p\".\"category_id\" // Create sql Alias elements: dots are considered part of the alias expression $alias = Sql::alias('t0'); // sql-string: \"t0\" $alias = Sql::alias('my.Alias'); // sql-string: \"my.Alias\" // Create parametric sql Expression elements: // substitution parameter markers must be enclosed in curly brackets $expr = Sql::expression('(price * {vat_rate})', [ 'vat_rate' => 20.0, ]); // sql-string: (price * :expr1) // Using shorter method name `expr` // sql-string: CONCAT(:expr1, '', \"surname\") $expr = Sql::expr('CONCAT({title}, ' ', \"surname\")', ['title' => 'sir']); // Create parameter-less sql Literal expression elements: // substitution parameter markers must be enclosed in curly brackets $literal = Sql::literal('(\"price\" * 20.0)'); // sql-string: (price * 20.0) $select = Sql::select(); // returns a Statement\\Select instance $insert = Sql::insert(); // returns a Statement\\Insert instance $update = Sql::update(); // returns a Statement\\Update instance $delete = Sql::delete(); // returns a Statement\\Delete instance All the factory methods above can be replaced with constructor calls with the same signature. To make code more coincise a few importable functions are provided: use P3\\Db\\Sql\\alias as ali; use P3\\Db\\Sql\\expression as exp; use P3\\Db\\Sql\\identifier as idn; use P3\\Db\\Sql\\literal as lit; $column = idn('p.category_id'); $alias = ali('t0'); $expr = exp('(price * {vat_rate})', ['vat_rate' => 20.0]); $literal = lit('(\"price\" * 20.0)');","title":"Elements"},{"location":"sql/elements/#p3dbsqlelementinterface","text":"A sql element represents full sql statements or just part of it such as identifiers, aliases, predicate, clauses, etc... It provides a getSQL(DriverInterface $driver = null, Params $params = null) method that returns the compiled SQL-string for the elements itself with the help of the given driver and collects parameter values and types to be used when the sql-statements are being prepared to be sent to the database server. Sql elements can also be organized in hierarchies ( ElementInterface::setParent() ), but an element can have only one parent. Changes to an inner element must invalidate any compiled sql-string that has been cached.","title":"P3\\Db\\Sql\\ElementInterface"},{"location":"sql/elements/#p3dbsql","text":"The Db\\Sql class offers constants for common SQL keywords and static factory methods for creating complex or simple sql elements: use P3\\Db\\Sql; use P3\\Db\\Sql\\Alias; use P3\\Db\\Sql\\Expression; use P3\\Db\\Sql\\Literal; use P3\\Db\\Sql\\Identifier; use P3\\Db\\Sql\\Statement; // Create Identifier elements: dots are considered identifier separators $column = Sql::identifier('category_id'); // sql-string: \"category_id\" $column = Sql::identifier('p.category_id'); // sql-string: \"p\".\"category_id\" // Create sql Alias elements: dots are considered part of the alias expression $alias = Sql::alias('t0'); // sql-string: \"t0\" $alias = Sql::alias('my.Alias'); // sql-string: \"my.Alias\" // Create parametric sql Expression elements: // substitution parameter markers must be enclosed in curly brackets $expr = Sql::expression('(price * {vat_rate})', [ 'vat_rate' => 20.0, ]); // sql-string: (price * :expr1) // Using shorter method name `expr` // sql-string: CONCAT(:expr1, '', \"surname\") $expr = Sql::expr('CONCAT({title}, ' ', \"surname\")', ['title' => 'sir']); // Create parameter-less sql Literal expression elements: // substitution parameter markers must be enclosed in curly brackets $literal = Sql::literal('(\"price\" * 20.0)'); // sql-string: (price * 20.0) $select = Sql::select(); // returns a Statement\\Select instance $insert = Sql::insert(); // returns a Statement\\Insert instance $update = Sql::update(); // returns a Statement\\Update instance $delete = Sql::delete(); // returns a Statement\\Delete instance All the factory methods above can be replaced with constructor calls with the same signature. To make code more coincise a few importable functions are provided: use P3\\Db\\Sql\\alias as ali; use P3\\Db\\Sql\\expression as exp; use P3\\Db\\Sql\\identifier as idn; use P3\\Db\\Sql\\literal as lit; $column = idn('p.category_id'); $alias = ali('t0'); $expr = exp('(price * {vat_rate})', ['vat_rate' => 20.0]); $literal = lit('(\"price\" * 20.0)');","title":"P3\\Db\\Sql"},{"location":"sql/statements/","text":"p3\\Db\\Sql\\Statement","title":"Statements"},{"location":"sql/statements/#p3dbsqlstatement","text":"","title":"p3\\Db\\Sql\\Statement"}]}