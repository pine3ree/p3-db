{
    "docs": [
        {
            "location": "/",
            "text": "p3-db\n\n\nP3\\Db\n is a small database abstraction layer on top of the \n\\PDO\n library.\n\n\nIt provides a simple sql builder and convenience methods for common CRUD opeations.\n\n\nThe DBAL instance consists of a simple PDO connection wrapper that can use an existing connection\nor instantiate a new lazy pdo connection on demand.\n\n\nBasic database operations for retrieving, inserting, updating and deleting rows from/into\na given database table leverage a set of database Command classes, which in turn\ncompose the database connection itself and a corresponding sql abstraction statement object.\n\n\nThe sql-command building operations are forwarded to the composed sql abstraction layer object,\nwhile the sql statement preparation, parameter binding and command execution are\nperformed by the composed DBAL instance.\n\n\nInstallation\n\n\np3-db DBAL can be installed via composer\n\n\n$ composer require pine3ree/p3-db\n\n\n\n\nThe package does not provide any stable version yet, so \n\"minimum-stability\": \"dev\"\n\nsetting is required in your \ncomposer.json\n file.",
            "title": "p3-db"
        },
        {
            "location": "/#p3-db",
            "text": "P3\\Db  is a small database abstraction layer on top of the  \\PDO  library.  It provides a simple sql builder and convenience methods for common CRUD opeations.  The DBAL instance consists of a simple PDO connection wrapper that can use an existing connection\nor instantiate a new lazy pdo connection on demand.  Basic database operations for retrieving, inserting, updating and deleting rows from/into\na given database table leverage a set of database Command classes, which in turn\ncompose the database connection itself and a corresponding sql abstraction statement object.  The sql-command building operations are forwarded to the composed sql abstraction layer object,\nwhile the sql statement preparation, parameter binding and command execution are\nperformed by the composed DBAL instance.",
            "title": "p3-db"
        },
        {
            "location": "/#installation",
            "text": "p3-db DBAL can be installed via composer  $ composer require pine3ree/p3-db  The package does not provide any stable version yet, so  \"minimum-stability\": \"dev\" \nsetting is required in your  composer.json  file.",
            "title": "Installation"
        },
        {
            "location": "/db/",
            "text": "P3\\Db\n\n\nQuick start\n\n\nuse P3\\Db;\nuse P3\\Db\\Factory\\DbFactory;\nuse PDO;\n\n// 1. Create a dbal instance using an existing PDO connection\n$pdo = new PDO('my-db-dsn', 'my-db-username', 'my-db-password');\n$db = new Db($pdo);\n\n// 2. Create a dbal instance using pdo configuration: the PDO connection is created on demand\n$db = new Db('my-db-dsn', 'my-db-username', 'my-db-password');\n\n// 3. Create a dbal instance using a factory: the provided factory fetch a configuration\n// array from a psr-container under the `config` id/alias with specific database\n// configuration subarray under either a `db` or `pdo` key.\n$factory = new DbFactory();\n$db = $factory($container);\n\n// fetch all rows from the \"product\" table\n$products = $db->fetchAll('product');\n\n// fetch the product row with column id = 42\n$product = $db->fetchOneBy('product', 'id', 42);\n\n// same row using `fetchOne()` with condition\n$product = $db->fetchOne('product', ['id' => 42]);\n\n$fiftyExpensiveProducts = $db->fetchAll('product', [\n    ['price', '>', 1000.00],\n], ['price' => 'ASC'], 50);\n\n$tenMostExpensiveProducts = $db->fetchAll('product', null, ['price' => 'DESC'], 10);\n\n$mostExpensiveProduct = $db->fetchOne('product', null, ['price' => 'DESC']);\n\n\n\n\n\nConstructor arguments\n\n\nP3\\Db\n supports the same constructor arguments as the \n\\PDO\n class.\n\n\nIt also supports an extra argument, an optional custom PDO subclass to use in\nlazy connection instances.\n\n\nclass Db\n{\n   /**\n     * @param string|PDO $dsn_or_pdo A valid pdo dsn string or an existing pdo connection instance\n     * @param string|null $username PDO connection username\n     * @param string|null $password PDO connection password\n     * @param array|null $options PDO connection options\n     * @param string|null $pdoClass An optional PDO subclass to use when creating a new connection\n     */\n    public function __construct(\n        $dsn_or_pdo,\n        string $username = null,\n        string $password = null,\n        array $options = null,\n        string $pdoClass = null\n    ) {\n}\n//...\n\n\n\n\nThe first argument can also be an existing PDO instance itself, that will be used\nas the composed pdo connection.\n\n\nFactory configuration parameters\n\n\nFactory configuration retrieved from the container should return an array like the\none below:\n\n\n// file config.php\nreturn [\n    // full dsn specification\n    'db' => [ // alt key: 'pdo' => [...]\n        'dns'      => 'mysql:dbname=testdb;host=localhost;port=3306;charset=utf8',\n        'username' => 'testuser', // alt key: 'user'\n        'password' => 'secret', // alt key: 'passwd' or 'pass'\n    ],\n    // ...or single parameters specs\n    'db' => [\n        'driver'   => 'mysql',\n        'dbname'   => 'testdb', // alt key: 'database'\n        'host'     => 'localhost', // alt key: 'hostname'\n        'port'     => 3306,\n        'charset'  => 'utf8',\n        'username' => 'testuser', // alt key: 'user'\n        'password' => 'secret', // alt key: 'passwd' or 'pass'\n        'options'  => [\n            // pdo-options array\n        ]\n    ],\n];\n\n\n\n\nThe database configuration subkeys depend on the db driver used and must be all\nin snake_case format. Please check the pdo driver page https://www.php.net/manual/en/pdo.drivers.php\nfor more information.\n\n\nThe factory will attempt to build a valid pdo DSN with the provided configuration parameters.\n\n\nSupported drivers are \nmysql\n, \npgsql\n, \nsqlite\n, \nsqlsrv\n and \noci\n.\n\n\nCRUD commands\n\n\nTo start building a crud databse command you can use the following methods:\n\n\n$select = $db->select(); // returns a P3\\Db\\Command\\Select instance\n$insert = $db->insert(); // returns a P3\\Db\\Command\\Insert instance\n$update = $db->update(); // returns a P3\\Db\\Command\\Update instance\n$delete = $db->delete(); // returns a P3\\Db\\Command\\Delete instance\n\n\n\n\nDatabase command instances provide a fluent interface for building sql statement.\nThe sql build is actually perfomed by the composed sql-statement (\nP3\\Db\\Sql\\Statement\n)\ninstance with the help of the sql-driver (\nP3\\Sql\\DriverInterface\n) created for\nthe current connection.\n\n\nThe corresponding sql-statement objects ca be created with the following \nP3\\Db\\Sql\n helper\nclass static methods:\n\n\n$select = Sql::select(); // returns a P3\\Db\\Sql\\Statement\\Select instance\n$insert = Sql::insert(); // returns a P3\\Db\\Sql\\Statement\\Insert instance\n$update = Sql::update(); // returns a P3\\Db\\Sql\\Statement\\Update instance\n$delete = Sql::delete(); // returns a P3\\Db\\Sql\\Statement\\Delete instance\n\n\n\n\nThe \nSql\\Statement\n classes, as any other \nSql\\Element\n class, provide a \ngetSQL()\n\nmethod which compiles the sql string for the given sql-driver argument or the default\n\nAnsi\n driver. The sql-drivers provide identifier quoting and other sql transformations\naccording to the underlying platform. The \ngetSQL()\n method also collects user-provided\nparameter values along with their pdo-param types and sets named markers in their place\ninto the sql string. The paramater collector can be retrieved by \ngetParams()\n either from\nthe sql-statement object or the wrapping command. A internal collector will be created\nonly if not passed-in as the 2nd argument of the \ngetSQL()\n call.\n\n\nDb::select()\n\n\nCreate a select command instance, which is a reader-command, whose method \nexecute()\n\nis forwarded to the reader-command method \nquery()\n:\n\n\n$select = $db->select(); // generic Select command\n\n// SELECT * FROM \"product\" \"p\"\n$select = $db->select('*', 'product', 'p');\n// equivalent to\n$select = $db->select('*')->from('product', 'p');\n// and to\n$select = $db->select()->from('product', 'p');\n\n // SELECT \"p\".\"price\", \"p\".\"vat_rate\" AS \"vatRate\" FROM \"product\" \"p\"\n$select = $db->select(['price', 'vat_rate' => 'vatRate'])->from('product', 'p');\n\n// add where condition and order-by clause\n$select->where->lte('price', 1000.0); // WHERE \"price\" <= :lte1 (named parameter marker)\n$select->orderBy('p.price', 'ASC'); // ORDER BY \"price\" ASC\n\n// SELECT \"p\".* FROM \"product\" \"p\" ORDER BY \"p\".\"price\" ASC\n$select = $db->select('*')->from('product', 'p')->orderBy('p.price');\n\n$stmt = $select->execute(); // or $select->query(), returns a PDOStatement or FALSE\n\n// SELECT \"category_id\" AS \"catId\", COUNT(*) AS \"numProducts\"\n// FROM \"product\" WHERE \"price\" > :gt1\n// GROUP BY \"category_id\"\n// HAVING \"numProducts\" >= :gte1\n$select = $db->select()\n    ->column('category_id', 'catId')\n    ->count('*', 'numProducts')\n    ->from('product');\n    ->where->gte('price', 10.0);\n// using $select->where or $select->having changes the scope and the fluent method\n// chain is broken\n$select->groupBy('category_id')\n    ->having->gt('numProducts', 5);\n// SELECT MIN(\"price\") FROM \"product\" GROUP BY \"category_id\"\n$select = $db->select()->min('price')->from('product')->groupBy('category_id');\n\n\n\n\nDb::insert()\n\n\nCreate and optionally execute an insert command instance, which is a writer-command.\n\n\nWriter commands (Insert, Update, Delete) method \nexecute()\n is forwarded to the\nwriter-command method \nexec()\n.\n\n\n// INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2)\n$insert = $db->insert()\n    ->into('product')\n    ->row([\n        'name' => 'product-1',\n        'price' => 100.00,\n    ]);\n\n// equivalent to\n$insert = $db->insert()\n    ->into('product')\n    ->columns(['name', 'price'])\n    ->values(['product-1', 100.00]);\n\n$result = $insert->execute() // or $insert->exec(), returns TRUE or FALSE for single row insert\n\n\n\n\nInsert and execute shortcut call, when both arguments (\n$table\n and \n$row\n/\n$rows\n)\nare provided:\n\n\n$result = $db->insert('product', [\n    'name' => 'product-111',\n    'price' => 111.11,\n]); // returns TRUE or FALSE for single insert\n\n// get the last generated value if the insert is successful\n$id = $result ? $db->lastInsertId() : null;\n\n\n\n\nInsert many rows:\n\n\n// INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2), (:val3, :val4)\n$num_inserted = $db->insert('product', [\n    [\n        'name' => 'product-111',\n        'price' => 111.11,\n    ],\n    [\n        'name' => 'product-222',\n        'price' => 222.22,\n    ],\n]); // returns integer or FALSE\n\n// equivalent to\n$num_inserted = $db->insert()\n    ->into('product')\n    ->columns(['name', 'price'])\n    ->values([\n        'product-111',\n        111.11,\n    ])\n    ->values([\n        'product-222',\n        222.22,\n    ])->execute(); // or exec()\n\n// and to\n$num_inserted = $db->insert()\n    ->into('product')\n    ->columns(['name', 'price'])\n    ->multipleValues([\n        [\n            'product-111',\n            111.11,\n        ],\n        [\n            'product-222',\n            222.22,\n        ],\n    ])->execute();",
            "title": "P3\\Db"
        },
        {
            "location": "/db/#p3db",
            "text": "",
            "title": "P3\\Db"
        },
        {
            "location": "/db/#quick-start",
            "text": "use P3\\Db;\nuse P3\\Db\\Factory\\DbFactory;\nuse PDO;\n\n// 1. Create a dbal instance using an existing PDO connection\n$pdo = new PDO('my-db-dsn', 'my-db-username', 'my-db-password');\n$db = new Db($pdo);\n\n// 2. Create a dbal instance using pdo configuration: the PDO connection is created on demand\n$db = new Db('my-db-dsn', 'my-db-username', 'my-db-password');\n\n// 3. Create a dbal instance using a factory: the provided factory fetch a configuration\n// array from a psr-container under the `config` id/alias with specific database\n// configuration subarray under either a `db` or `pdo` key.\n$factory = new DbFactory();\n$db = $factory($container);\n\n// fetch all rows from the \"product\" table\n$products = $db->fetchAll('product');\n\n// fetch the product row with column id = 42\n$product = $db->fetchOneBy('product', 'id', 42);\n\n// same row using `fetchOne()` with condition\n$product = $db->fetchOne('product', ['id' => 42]);\n\n$fiftyExpensiveProducts = $db->fetchAll('product', [\n    ['price', '>', 1000.00],\n], ['price' => 'ASC'], 50);\n\n$tenMostExpensiveProducts = $db->fetchAll('product', null, ['price' => 'DESC'], 10);\n\n$mostExpensiveProduct = $db->fetchOne('product', null, ['price' => 'DESC']);",
            "title": "Quick start"
        },
        {
            "location": "/db/#constructor-arguments",
            "text": "P3\\Db  supports the same constructor arguments as the  \\PDO  class.  It also supports an extra argument, an optional custom PDO subclass to use in\nlazy connection instances.  class Db\n{\n   /**\n     * @param string|PDO $dsn_or_pdo A valid pdo dsn string or an existing pdo connection instance\n     * @param string|null $username PDO connection username\n     * @param string|null $password PDO connection password\n     * @param array|null $options PDO connection options\n     * @param string|null $pdoClass An optional PDO subclass to use when creating a new connection\n     */\n    public function __construct(\n        $dsn_or_pdo,\n        string $username = null,\n        string $password = null,\n        array $options = null,\n        string $pdoClass = null\n    ) {\n}\n//...  The first argument can also be an existing PDO instance itself, that will be used\nas the composed pdo connection.",
            "title": "Constructor arguments"
        },
        {
            "location": "/db/#factory-configuration-parameters",
            "text": "Factory configuration retrieved from the container should return an array like the\none below:  // file config.php\nreturn [\n    // full dsn specification\n    'db' => [ // alt key: 'pdo' => [...]\n        'dns'      => 'mysql:dbname=testdb;host=localhost;port=3306;charset=utf8',\n        'username' => 'testuser', // alt key: 'user'\n        'password' => 'secret', // alt key: 'passwd' or 'pass'\n    ],\n    // ...or single parameters specs\n    'db' => [\n        'driver'   => 'mysql',\n        'dbname'   => 'testdb', // alt key: 'database'\n        'host'     => 'localhost', // alt key: 'hostname'\n        'port'     => 3306,\n        'charset'  => 'utf8',\n        'username' => 'testuser', // alt key: 'user'\n        'password' => 'secret', // alt key: 'passwd' or 'pass'\n        'options'  => [\n            // pdo-options array\n        ]\n    ],\n];  The database configuration subkeys depend on the db driver used and must be all\nin snake_case format. Please check the pdo driver page https://www.php.net/manual/en/pdo.drivers.php\nfor more information.  The factory will attempt to build a valid pdo DSN with the provided configuration parameters.  Supported drivers are  mysql ,  pgsql ,  sqlite ,  sqlsrv  and  oci .",
            "title": "Factory configuration parameters"
        },
        {
            "location": "/db/#crud-commands",
            "text": "To start building a crud databse command you can use the following methods:  $select = $db->select(); // returns a P3\\Db\\Command\\Select instance\n$insert = $db->insert(); // returns a P3\\Db\\Command\\Insert instance\n$update = $db->update(); // returns a P3\\Db\\Command\\Update instance\n$delete = $db->delete(); // returns a P3\\Db\\Command\\Delete instance  Database command instances provide a fluent interface for building sql statement.\nThe sql build is actually perfomed by the composed sql-statement ( P3\\Db\\Sql\\Statement )\ninstance with the help of the sql-driver ( P3\\Sql\\DriverInterface ) created for\nthe current connection.  The corresponding sql-statement objects ca be created with the following  P3\\Db\\Sql  helper\nclass static methods:  $select = Sql::select(); // returns a P3\\Db\\Sql\\Statement\\Select instance\n$insert = Sql::insert(); // returns a P3\\Db\\Sql\\Statement\\Insert instance\n$update = Sql::update(); // returns a P3\\Db\\Sql\\Statement\\Update instance\n$delete = Sql::delete(); // returns a P3\\Db\\Sql\\Statement\\Delete instance  The  Sql\\Statement  classes, as any other  Sql\\Element  class, provide a  getSQL() \nmethod which compiles the sql string for the given sql-driver argument or the default Ansi  driver. The sql-drivers provide identifier quoting and other sql transformations\naccording to the underlying platform. The  getSQL()  method also collects user-provided\nparameter values along with their pdo-param types and sets named markers in their place\ninto the sql string. The paramater collector can be retrieved by  getParams()  either from\nthe sql-statement object or the wrapping command. A internal collector will be created\nonly if not passed-in as the 2nd argument of the  getSQL()  call.",
            "title": "CRUD commands"
        },
        {
            "location": "/db/#dbselect",
            "text": "Create a select command instance, which is a reader-command, whose method  execute() \nis forwarded to the reader-command method  query() :  $select = $db->select(); // generic Select command\n\n// SELECT * FROM \"product\" \"p\"\n$select = $db->select('*', 'product', 'p');\n// equivalent to\n$select = $db->select('*')->from('product', 'p');\n// and to\n$select = $db->select()->from('product', 'p');\n\n // SELECT \"p\".\"price\", \"p\".\"vat_rate\" AS \"vatRate\" FROM \"product\" \"p\"\n$select = $db->select(['price', 'vat_rate' => 'vatRate'])->from('product', 'p');\n\n// add where condition and order-by clause\n$select->where->lte('price', 1000.0); // WHERE \"price\" <= :lte1 (named parameter marker)\n$select->orderBy('p.price', 'ASC'); // ORDER BY \"price\" ASC\n\n// SELECT \"p\".* FROM \"product\" \"p\" ORDER BY \"p\".\"price\" ASC\n$select = $db->select('*')->from('product', 'p')->orderBy('p.price');\n\n$stmt = $select->execute(); // or $select->query(), returns a PDOStatement or FALSE\n\n// SELECT \"category_id\" AS \"catId\", COUNT(*) AS \"numProducts\"\n// FROM \"product\" WHERE \"price\" > :gt1\n// GROUP BY \"category_id\"\n// HAVING \"numProducts\" >= :gte1\n$select = $db->select()\n    ->column('category_id', 'catId')\n    ->count('*', 'numProducts')\n    ->from('product');\n    ->where->gte('price', 10.0);\n// using $select->where or $select->having changes the scope and the fluent method\n// chain is broken\n$select->groupBy('category_id')\n    ->having->gt('numProducts', 5);\n// SELECT MIN(\"price\") FROM \"product\" GROUP BY \"category_id\"\n$select = $db->select()->min('price')->from('product')->groupBy('category_id');",
            "title": "Db::select()"
        },
        {
            "location": "/db/#dbinsert",
            "text": "Create and optionally execute an insert command instance, which is a writer-command.  Writer commands (Insert, Update, Delete) method  execute()  is forwarded to the\nwriter-command method  exec() .  // INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2)\n$insert = $db->insert()\n    ->into('product')\n    ->row([\n        'name' => 'product-1',\n        'price' => 100.00,\n    ]);\n\n// equivalent to\n$insert = $db->insert()\n    ->into('product')\n    ->columns(['name', 'price'])\n    ->values(['product-1', 100.00]);\n\n$result = $insert->execute() // or $insert->exec(), returns TRUE or FALSE for single row insert  Insert and execute shortcut call, when both arguments ( $table  and  $row / $rows )\nare provided:  $result = $db->insert('product', [\n    'name' => 'product-111',\n    'price' => 111.11,\n]); // returns TRUE or FALSE for single insert\n\n// get the last generated value if the insert is successful\n$id = $result ? $db->lastInsertId() : null;  Insert many rows:  // INSERT INTO \"product\" (\"name\", \"price\") VALUES (:val1, :val2), (:val3, :val4)\n$num_inserted = $db->insert('product', [\n    [\n        'name' => 'product-111',\n        'price' => 111.11,\n    ],\n    [\n        'name' => 'product-222',\n        'price' => 222.22,\n    ],\n]); // returns integer or FALSE\n\n// equivalent to\n$num_inserted = $db->insert()\n    ->into('product')\n    ->columns(['name', 'price'])\n    ->values([\n        'product-111',\n        111.11,\n    ])\n    ->values([\n        'product-222',\n        222.22,\n    ])->execute(); // or exec()\n\n// and to\n$num_inserted = $db->insert()\n    ->into('product')\n    ->columns(['name', 'price'])\n    ->multipleValues([\n        [\n            'product-111',\n            111.11,\n        ],\n        [\n            'product-222',\n            222.22,\n        ],\n    ])->execute();",
            "title": "Db::insert()"
        }
    ]
}